# План реализации NewSluhy

Поэтапный порядок действий по реализации Telegram-бота на основании PROJECT.md.

---

## Этап 1. Инициализация проекта

- [x] Создать Next.js-проект (App Router).
- [x] Настроить TypeScript, ESLint, структуру папок.
- [x] Добавить зависимости: для Telegram API, для работы с AI (OpenAI/другой провайдер), для парсинга и поиска (по необходимости).
- [x] Создать `.env` с переменными: `TELEGRAM_BOT_TOKEN`, ключи для AI и поиска.

---

## Этап 2. Webhook-обработчик Telegram

- [x] Реализовать API-маршрут (например, `app/api/webhook/route.ts`), принимающий **POST** от Telegram.
- [x] В обработчике:
  - извлечь `chat.id` и `text` из `update.message`;
  - поддержать также `message.entities` (ссылки) и при необходимости `forward_from` / ссылку на пост.
- [x] Сразу отправить ответ пользователю (например, «Обрабатываю…») через Telegram API `sendMessage`.
- [x] Вернуть **200 OK** быстро, без выполнения долгих операций в этом же запросе.
- [x] Обработку (поиск источников, AI) выполнять асинхронно после ответа 200 (фоновая задача или отдельный вызов после ответа).

---

## Этап 3. Получение и извлечение текста

- [x] Если пользователь прислал **текст** — использовать его как есть.
- [x] Если пользователь прислал **ссылку на Telegram-пост** — реализовать получение текста поста (Telegram Bot API или парсинг, в зависимости от доступных методов).
- [x] Нормализовать текст: обрезка лишних пробелов, приведение к единому формату для дальнейших этапов.

---

## Этап 4. Выделение сущностей из текста

- [x] Реализовать выделение:
  - ключевых утверждений (факты, тезисы);
  - дат;
  - чисел (в т.ч. статистика);
  - имён (персоны, организации);
  - ссылок.
- [x] Варианты: правила/регулярки + при необходимости вызов AI для извлечения утверждений и сущностей. Результат — структурированный объект (список утверждений + сущности).

---

## Этап 5. Поиск возможных источников

- [x] Реализовать поиск по выделенным утверждениям и сущностям:
  - официальные сайты (госструктуры, компании по именам);
  - новостные сайты;
  - блоги и медиа;
  - научные/исследовательские источники (при необходимости).
- [x] Использовать поисковый API (Google Custom Search, Bing, SerpAPI и т.п.) или специализированные API новостей/исследований.
- [x] Отбирать кандидатов источников (например, топ 5–10 URL) для следующего этапа.

---

## Этап 6. Сравнение смысла через AI и формирование ответа

- [ ] Передать в AI: исходный текст/утверждения + список кандидатов (URL + заголовки/сниппеты или краткое содержание).
- [ ] Запросить у AI сравнение **по смыслу** (не буквальное совпадение): насколько каждый источник подтверждает или опровергает утверждения.
- [ ] Получить от AI: 1–3 лучших источника + оценка уверенности (например, в процентах или уровнях).
- [ ] Сформировать итоговое сообщение для пользователя: список ссылок + краткая оценка уверенности.

---

## Этап 7. Отправка результата пользователю

- [ ] После завершения асинхронной обработки вызвать Telegram API `sendMessage` с готовым ответом (источники + оценка).
- [ ] Обработать ошибки (таймаут, недоступность API, пустой результат) и отправить пользователю понятное сообщение об ошибке.

---

## Этап 8. Деплой и настройка

- [ ] Подключить репозиторий к Vercel, настроить переменные окружения.
- [ ] Указать в Vercel URL webhook-маршрута и зарегистрировать webhook в Telegram через `setWebhook`.
- [ ] Провести сквозные тесты: текст, ссылка на пост, проверка быстрого 200 OK и прихода ответа с источниками.

---

## Порядок этапов (кратко)

1. Инициализация проекта и окружение  
2. Webhook: принять POST, быстрый ответ 200 и «Обрабатываю…»  
3. Извлечение текста (прямой ввод или из ссылки на пост)  
4. Выделение сущностей (утверждения, даты, числа, имена, ссылки)  
5. Поиск кандидатов источников (официальные, новости, блоги, исследования)  
6. AI: сравнение по смыслу, выбор 1–3 источников и оценка уверенности  
7. Отправка результата пользователю в Telegram  
8. Деплой на Vercel и настройка webhook  

После выполнения этапов 1–2 бот уже принимает сообщения и может отвечать; этапы 3–7 реализуют полный сценарий «текст/ссылка → источники».
